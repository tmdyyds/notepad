## 设计原则

- SOLID 原则 -SRP 单一职责原则

> 一个类或模块只负责一个职责

- SOLID 原则 -OCP 开闭原则

> 软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”
>
> https://time.geekbang.org/column/article/176075 代码例子很好

- SOLID 原则 -LSP 里式替换原则

> 子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏

- SOLID 原则 -ISP 接口隔离原则

> 客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者

- SOLID 原则 -DIP 依赖倒置原则

> 高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）

- 控制反转、依赖注入、依赖反转

> https://time.geekbang.org/column/article/177444

## 设计模式分类

#### 创建型

> 常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式
>
> 不常用的有：原型模式

#### 结构型

> 常用的有：代理模式、桥接模式、装饰者模式、适配器模式
>
> 不常用的有：门面模式、组合模式、享元模式

#### 行为型

> 常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式
>
> 不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式

## 面向对象

#### 四大特征

> 封装、继承、多态、抽象
>
> 封装主要讲如何隐藏信息、保护数据
>
> 抽象主要讲如何隐藏方法的具体实现(接口类和抽象类)
>
> 多态就是对象的运行时状态可以随着实际给定的子类的类型改变而改变，基类对象可以表现出不同子类的行为

#### 接口与抽象区别和联系

> 接口不能包含属性（也就是成员变量）。
>
> 接口只能声明方法，方法不能包含代码实现。
>
> 类实现接口的时候，必须实现接口中声明的所有方法。
>
> 
>
> 抽象类不允许被实例化，只能被继承。
>
> 抽象类可以包含属性和方法。
>
> 子类继承抽象类，必须实现抽象类中的所有抽象方法。
>
> 抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。继承关系是一种 is-a 的关系，那**抽象类既然属于类，也表示一种 is-a 的关系**。相对于抽象类的 is-a 关系来说，接口表示一种 **has-a 关系，表示具有某些功能**。对于接口，有一个更加形象的叫法，那就是协议（contract）。
>
> **抽象类更多的是为了代码复用，而接口就更侧重于解耦。**接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。
>
> 
>
> **接口与抽象选择：**
>
> 如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。
>
> 抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。



